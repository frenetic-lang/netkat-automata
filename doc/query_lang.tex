\documentclass[12pt]{article}
\title{Query Language Semantics and Compilation}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{tikz}

\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\setst}[2]{\left\{#1 \>\middle|\> #2 \right\}}
\newcommand{\carets}[1]{\left\langle #1 \right\rangle}
\newcommand{\parens}[1]{\left( #1 \right)}
\newcommand{\figref}[1]{Figure \ref{fig:#1}}
\newcommand{\dst}{\text{dst}}
\newcommand{\pt}{\text{pt}}
\newcommand{\sw}{\text{sw}}
\newcommand{\typ}{\text{typ}}
\newcommand{\http}{\text{http}}
\newcommand{\dup}{\text{dup}}
\newcommand{\denote}[1]{\text{$[\![ $#1$ ]\!]$}}

\begin{document}
\maketitle

\section{Syntax}
\paragraph{Naturals, fields, and packets}
\begin{align*}
  n  &::= 0 | 1 | 2 | \ldots \\
  f  &::= f_1 | \cdots | f_k \\
  pk &::= \set{f_1 = n_1, \ldots, f_k = n_k} \\
 net &::= (in, out, p, t)
\end{align*}

\paragraph{Predicates}
\begin{align*}
  a, b &::= 1 \\
       &| 0 \\
       &| f = n \\
       &| a \lor b \\
       &| a \land b \\
       &| \lnot a
\end{align*}

\paragraph{Queries}
\begin{align*}
  q, q' &::= (a, b) \\
        &| q + q'  \\
        &| q \cdot q' \\
        &| q^*
\end{align*}

\section{Semantics}
\paragraph{Language interpretation of NetKAT} This is similar to $R$ in the
original NetKAT paper.
\begin{align*}
  R(p) &= \text{range}(\denote{p})
\end{align*}

\paragraph{Language interpretation of query language} Recall that a network
topology $t$ has the following form
\[
  \dup \cdot [sw_1:pt_1] \to [sw_2:pt_2] \cdot \dup
\]
which is short hand for
\[
  \dup \cdot
  \sw =     sw_1 \cdot \pt =     pt_1 \cdot
  \sw \gets sw_2 \cdot \pt \gets pt_2 \cdot
  \dup
\]
Notice in particular that there is a dup at the beginning and end of $t$.
Now consider the network $in \cdot (p \cdot t)^* \cdot p \cdot out$. Every time
a packet traverses an edge in the network and is processed by $p \cdot t$, two
packets are prepended to the packet history, and this pair of packets
represents the edge traversed.

For example, consider the simple linear network, $l$ presented in the original
NetKAT paper. I'll denote the packet $\set{\sw=s, \pt=n}$ by $s_n$.
\[
  \denote{l}(\carets{A_1}) = B_2 :: B_1 :: A_2
\]
The pair of packets $B_1::A_2$ represents the edge from switch $A$ to switch
$B$. In general, we can represent a path through the network as a history and a
set of paths as a set of histories.

We think of our query language as regular expressions over the alphabet of
edges. As we just showed, we can represent an edge as a pair of packets. Here,
we use a pair of packet predicates.
\begin{align*}
  L((a, b))    &= \setst{pk_b :: \carets{pk_a}}{pk_a \in R(a), pk_b \in R(b)} \\
  L(q + q')    &= L(q) \cup L(q') \\
  L(q \cdot q) &= \setst{h' :: h}{h \in L(q), h' \in L(q')} \\
  L(q^*)       &= \bigcup_{i=0}^\infty q^i
\end{align*}

Here are some example queries:
\begin{itemize}
  \item No paths:
    $(0, 0)$
  \item All paths:
    $(1, 1)^*$
  \item Paths of length $n$:
    $(1, 1)^n$
  \item A single path:
    $(c_4, d_3) \cdot (d_2, e_4) \cdot (e_2, b_4) \cdot (b_1, a_2)$
  \item All paths that include a given edge:
    $(1, 1)^* \cdot (a_1, b_2) \cdot (1, 1)^*$
  \item All paths that include a given path:
    $(1, 1)^* \cdot (c_4, d_3) \cdot (d_2, e_4) \cdot (e_2, b_4) \cdot (b_1, a_2) \cdot (1, 1)^*$
  \item All paths including a bidirectional edge:
    $(1, 1)^* \cdot ((a_1, b_2) + (b_2, a_1)) \cdot (1, 1)^*$
  \item All paths traversed by HTTP traffic:
    $(\typ=\http, \typ=\http)^*$
  \item All paths from host $A$ to host $Z$:
    $(\sw=A, \sw=Z) + ((\sw=A, 1) \cdot (1, 1)^* \cdot (1, \sw=Z))$
\end{itemize}

\section{Compilation}
Remember that a network $in \cdot (p \cdot t)^* \cdot p \cdot out$ unwraps to
something like
\[
  in \cdot (p \cdot dup \cdot t' \cdot dup)^* \cdot p \cdot out
\]
where $t'$ is $\Phi(t)$. We can again unwrap this into a bunch of terms:
\begin{gather*}
  in \cdot p \cdot out \\
  in \cdot
  (p \cdot dup \cdot t' \cdot dup)
  \cdot p \cdot out \\
  in \cdot
  (p \cdot dup \cdot t' \cdot dup) \cdot
  (p \cdot dup \cdot t' \cdot dup)
  \cdot p \cdot out \\
  in \cdot
  (p \cdot dup \cdot t' \cdot dup) \cdot
  (p \cdot dup \cdot t' \cdot dup) \cdot
  (p \cdot dup \cdot t' \cdot dup)
  \cdot p \cdot out \\
  \cdots
\end{gather*}

In order to match a specific path, $(a_1, b_2) \cdot (b_3, c_4)$ for example,
we simply replace the dups with our predicates. If there are too few or too
many dups, we drop the term.

\begin{gather*}
  in \cdot p \cdot out \tag{too few dups} \\
  in \cdot
  (p \cdot a_1 \cdot t' \cdot b_2)
  \cdot p \cdot out \tag{too few dups} \\
  in \cdot
  (p \cdot a_1 \cdot t' \cdot b_2) \cdot
  (p \cdot b_3 \cdot t' \cdot c_4)
  \cdot p \cdot out \tag{good!} \\
  in \cdot
  (p \cdot a_1 \cdot t' \cdot b_2) \cdot
  (p \cdot b_3 \cdot t' \cdot c_4) \cdot
  (p \cdot dup \cdot t' \cdot dup)
  \cdot p \cdot out \tag{too many dups} \\
  \cdots
\end{gather*}

Intuitively, we're checking that a network accepts a set of paths by unwrapping
the query into the network replacing dups with predicates.

\paragraph{Compilation helper}
\begin{align*}
  H_{net}((a, b))     &= p \cdot a \cdot t' \cdot b \\
  H_{net}(q + q')     &= H_{net}(q) + H_{net}(q') \\
  H_{net}(q \cdot q') &= H_{net}(q) \cdot H_{net}(q') \\
  H_{net}(q^*)        &= H_{net}(q)^*
\end{align*}

\paragraph{Compilation}
\begin{align*}
  C_{net}(q) &= in \cdot H_{net}(q) \cdot p \cdot out
\end{align*}

\section{Correctness}
For a given NetKAT term $p$, let $A_p = \setst{\alpha}{\epsilon_{\alpha,
\beta}(p)}$ and $B_p = \setst{\beta}{\epsilon_{\alpha, \beta}(p)}$. That is,
$A_p$ and $B_p$ are the sets of $\alpha$s and $\beta$s with 1's in the E-matrix
of $p$.

We want $C_{net}(q)$ to satisfy the following:
\[
  L(q) \cap R(\Phi(net)) = \bigcup_{\alpha \in A_{C_{net}(q)}}{\denote{net}(\alpha)}
\]
Intuitively it says to take all the paths matched by our query, $L(q)$, and
intersect them with all paths permitted by the network, $R(\Phi(net))$. This
set is generated by the packets matching all the $\alpha$s in the E-matrix of
our compiled term $C_{net}(q)$.
\end{document}
